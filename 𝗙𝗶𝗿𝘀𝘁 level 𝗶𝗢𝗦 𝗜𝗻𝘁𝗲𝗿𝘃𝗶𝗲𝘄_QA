1.) what is AutoLayout ?

Auto Layout is a constraint-based layout system used in iOS to create responsive user interfaces.
It automatically adjusts the size and position of views based on constraints, ensuring the UI looks good on different screen sizes and orientations.
It helps maintain a consistent layout across all Apple devices.


1.1) Difference between var and let ?

**var** is used to declare a variable whose value can be changed (mutable), 
**let** is used to declare a constant whose value cannot be changed (immutable).
Using let improves code safety by preventing accidental changes to values.


1.2) what is computed property and stored property 
stored property stores the values 
computed property calculates and returns a value

A stored property actually stores a value in memory, while a computed property calculates its value dynamically based on other data.
Stored properties are declared with var or let, whereas computed properties use var with a get (and optionally set) block.

struct Person {
    var firstName: String      // stored property
    var lastName: String       // stored property
    
    var fullName: String {      // computed property
        return "\(firstName) \(lastName)"
    }
}


2.) what is Optional ?

Optionals in Swift are used to represent a variable that can hold either a value or nil (no value). They help safely handle the absence of a value without crashing the app. You declare an optional by adding ? after the type, like String?.

optional are swift features were a variable can hold a value or it can be nil and Optionals can  be handled in multiple ways nil coalescing optional binding guard statement and force unwrap


2.1.)  What is the difference between UIKit and SwiftUI?

UIKit is the traditional framework for building iOS apps, while SwiftUI is a newer, declarative framework that allows for faster development and less boilerplate code.

UIKit is an imperative framework where we build and update the UI step-by-step using Storyboards or programmatically. It gives more control but requires more boilerplate code.
SwiftUI is a declarative framework introduced by Apple that allows us to build UI using less code, with automatic updates when the state changes. Itâ€™s modern and suitable for cross-platform Apple development.


3.) ğ—˜ğ˜…ğ—½ğ—¹ğ—®ğ—¶ğ—» ğ˜ğ—µğ—² ğ——ğ—²ğ—¹ğ—²ğ—´ğ—®ğ˜ğ—² ğ—½ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—» ğ—¶ğ—» ğ—¶ğ—¢ğ—¦.

The Delegate pattern in iOS is a design pattern that allows one object to communicate back to another in a decoupled way.
Itâ€™s commonly used to handle user interactions or pass data, like responding to a button tap or table view selection.
It works by defining a protocol and assigning a delegate property, which is implemented by another class.
This helps keep code modular and maintainable.


4.) ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ the swift latest version ios version xcode version

Swift 6.1 Xcode 16  iOS 18.5  OR  Swift 6 Xcode 16  iOS 18


5.) ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ˜ğ—µğ—² ğ—±ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—² ğ—¯ğ—²ğ˜ğ˜„ğ—²ğ—²ğ—» ğ—¦ğ˜ğ—¼ğ—¿ğ˜†ğ—¯ğ—¼ğ—®ğ—¿ğ—± ğ—®ğ—»ğ—± ğ—«ğ—œğ—• ğ—³ğ—¶ğ—¹ğ—²ğ˜€?

Storyboard is a visual file that contains multiple view controllers and the transitions (segues) between them in a single interface.
XIB (or Nib) files are used to design individual UI components or single view controllers separately.
Storyboards are good for app flow visualization, while XIBs offer better modularity and easier reuse.
XIBs also load faster during development and reduce merge conflicts in teams.


6.) ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ—©ğ—¶ğ—²ğ˜„ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ ğ—¹ğ—¶ğ—³ğ—²ğ—°ğ˜†ğ—°ğ—¹ğ—² ğ—¶ğ—» ğ—¶ğ—¢ğ—¦?

viewDidLoad() â€“ called once when the view loads.

viewWillAppear() â€“ called just before the view appears.

viewDidAppear() â€“ called after the view appears.

viewWillDisappear() â€“ before it disappears.

viewDidDisappear() â€“ after it disappears.


7.) ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ app ğ—¹ğ—¶ğ—³ğ—²ğ—°ğ˜†ğ—°ğ—¹ğ—² ğ—¶ğ—» ğ—¶ğ—¢ğ—¦?

Not Running: The app is not launched yet.

Inactive: The app is in the foreground but not receiving input.

Active: The app is running and receiving events.

Background: The app is executing in the background.

Suspended: The app is in memory but not executing code.


8.) ğ—ªğ—µğ—®ğ˜ ğ—¶DataSource and Delegate

DataSource and Delegate are protocols used to separate data handling and user interaction logic in UIKit components like UITableView or UICollectionView.

DataSource provides the data (e.g., number of rows, cell content).

Delegate handles user interactions (e.g., row selection, editing).

UITableViewDataSource methods:               UITableViewDelegate methods:

numberOfRowsInSection                             didSelectRowAt

cellForRowAt                                      heightForRowAt


9.) What is a protocol in Swift?

A protocol in Swift defines a blueprint of methods, properties, or other requirements that a class, struct, or enum must adopt.
It allows for flexible and reusable code through abstraction.
Protocols support protocol-oriented programming, a key concept in Swift.

protocol Vehicle {
    func startEngine()
}

struct Car: Vehicle {
    func startEngine() {
        print("Car engine started")
    }
}


10.) What is an extension?

An extension allows you to add functionality to existing classes, structures, or enumerations without modifying their original implementation.

An extension in Swift is used to add new functionality to an existing class, struct, enum, or protocol without modifying its original source code.
It allows you to add methods, computed properties, and conform to protocols, helping keep your code organized and modular.

extension String {
    func isNumeric() -> Bool {
        return Double(self) != nil
    }
}

let value = "123"
print(value.isNumeric())


11.) Difference between Class and Struct 

The main difference is that classes are reference types, while structs are value types.

Class instances are shared via references; changes affect all references.

Struct instances are copied when assigned or passed, keeping data isolated.

Classes support inheritance, deinitializers, and reference counting, while structs do not.

âœ… When to Use Class and Struct:

Use **class** when:

You need inheritance, identity, or shared state.

Youâ€™re working with UIKit (e.g., UIView, UIViewController).

Use **struct** when:

You want safe, isolated, immutable copies.

Youâ€™re building data models in SwiftUI or functional architecture.


12.) when to use Class and when to use Struct ?

ğŸ”¸ 1. Class â€” Reference Type

Stored in Heap memory: Objects live in memory until there are no references left.

Pass-by-Reference: When assigned to a new variable, only the reference (pointer) is copied, not the data.

Supports Inheritance: Classes can inherit properties and methods from another class.

Mutable Even If Declared with let: Unlike structs, properties of a class can be modified even if the instance is assigned to a constant

When you assign it to a new variable or pass it to a function, it shares the same reference (points to the same instance).

Supports:

âœ… Inheritance

âœ… Deinitializers

âœ… Use cases:
When you need to share state across multiple places (e.g., view controllers, managers).

When you need inheritance (e.g., UIViewController).

When the model is complex and mutable.


ğŸ”¸ 2. Struct â€” Value Type

Stored in Stack memory: Structs are destroyed when they go out of scope, making them more memory efficient.

Pass-by-Value: Assigning a struct to a new variable copies the data

No Inheritance: Structs do not support inheritance

When you assign it to another variable or pass it to a function, it creates a copy.

Does not support:

âŒ Inheritance

âŒ Deinitializers

Structs are safer for data models when immutability or copying behavior is desired.

âœ… Use cases:

For lightweight data models (like coordinates, points, custom data types).

For safety and predictability (no unexpected changes from shared references).

Best for data-driven models in SwiftUI or value-type-based architectures.

