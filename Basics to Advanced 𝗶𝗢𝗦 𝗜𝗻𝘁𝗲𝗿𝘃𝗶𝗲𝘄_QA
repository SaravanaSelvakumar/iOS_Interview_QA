1.) what is AutoLayout ?

Auto Layout is a constraint-based layout system used in iOS to create responsive user interfaces.
It automatically adjusts the size and position of views based on constraints, ensuring the UI looks good on different screen sizes and orientations.
It helps maintain a consistent layout across all Apple devices.


1.1) Difference between var and let ?

**var** is used to declare a variable whose value can be changed (mutable), 
**let** is used to declare a constant whose value cannot be changed (immutable).
Using let improves code safety by preventing accidental changes to values.


1.2 ) what is computed property and stored property 
stored property stores the values 
computed property calculates and returns a value

A stored property actually stores a value in memory, while a computed property calculates its value dynamically based on other data.
Stored properties are declared with var or let, whereas computed properties use var with a get (and optionally set) block.

struct Person {
    var firstName: String      // stored property
    var lastName: String       // stored property
    
    var fullName: String {      // computed property
        return "\(firstName) \(lastName)"
    }
}


1.3 ) what is Optional ?

Optionals in Swift are used to represent a variable that can hold either a value or nil (no value). They help safely handle the absence of a value without crashing the app. You declare an optional by adding ? after the type, like String?.

optional are swift features were a variable can hold a value or it can be nil and Optionals can  be handled in multiple ways nil coalescing optional binding guard statement and force unwrap


2.) What's the difference between if let and guard let ?

"if let and guard let are both used for optional binding in Swift, but they serve different purposes in terms of control flow.
if let is typically used when I want to unwrap an optional and handle it within a conditional block ‚Äî the unwrapped value is only available inside the if scope.
On the other hand, guard let is used for early exit ‚Äî it's better for validating required conditions at the start of a function.
If the optional is nil, I can exit early using return or break, and the unwrapped value remains available in the rest of the function scope.
Personally, I prefer using guard let for input validation and cleaner flow, especially in functions or view lifecycle methods,
because it helps keep the happy path unindented and readable."


2.1.)  What is the difference between UIKit and SwiftUI?

UIKit is the traditional framework for building iOS apps, while SwiftUI is a newer, declarative framework that allows for faster development and less boilerplate code.

UIKit is an imperative framework where we build and update the UI step-by-step using Storyboards or programmatically. It gives more control but requires more boilerplate code.
SwiftUI is a declarative framework introduced by Apple that allows us to build UI using less code, with automatic updates when the state changes. It‚Äôs modern and suitable for cross-platform Apple development.


3.) ùóòùòÖùóΩùóπùóÆùó∂ùóª ùòÅùóµùó≤ ùóóùó≤ùóπùó≤ùó¥ùóÆùòÅùó≤ ùóΩùóÆùòÅùòÅùó≤ùóøùóª ùó∂ùóª ùó∂ùó¢ùó¶.

The Delegate pattern in iOS is a design pattern that allows one object to communicate back to another in a decoupled way.
It‚Äôs commonly used to handle user interactions or pass data, like responding to a button tap or table view selection.
It works by defining a protocol and assigning a delegate property, which is implemented by another class.
This helps keep code modular and maintainable.


4.) ùó™ùóµùóÆùòÅ ùó∂ùòÄ the swift latest version ios version xcode version

Swift 6.1 Xcode 16  iOS 18.5  OR  Swift 6 Xcode 16  iOS 18


5.) ùó™ùóµùóÆùòÅ ùó∂ùòÄ ùòÅùóµùó≤ ùó±ùó∂ùó≥ùó≥ùó≤ùóøùó≤ùóªùó∞ùó≤ ùóØùó≤ùòÅùòÑùó≤ùó≤ùóª ùó¶ùòÅùóºùóøùòÜùóØùóºùóÆùóøùó± ùóÆùóªùó± ùó´ùóúùóï ùó≥ùó∂ùóπùó≤ùòÄ?

Storyboard is a visual file that contains multiple view controllers and the transitions (segues) between them in a single interface.
XIB (or Nib) files are used to design individual UI components or single view controllers separately.
Storyboards are good for app flow visualization, while XIBs offer better modularity and easier reuse.
XIBs also load faster during development and reduce merge conflicts in teams.


6.) ùó™ùóµùóÆùòÅ ùó∂ùòÄ ùó©ùó∂ùó≤ùòÑùóñùóºùóªùòÅùóøùóºùóπùóπùó≤ùóø ùóπùó∂ùó≥ùó≤ùó∞ùòÜùó∞ùóπùó≤ ùó∂ùóª ùó∂ùó¢ùó¶?

viewDidLoad() ‚Äì called once when the view loads.

viewWillAppear() ‚Äì called just before the view appears.

viewDidAppear() ‚Äì called after the view appears.

viewWillDisappear() ‚Äì before it disappears.

viewDidDisappear() ‚Äì after it disappears.


7.) ùó™ùóµùóÆùòÅ ùó∂ùòÄ app ùóπùó∂ùó≥ùó≤ùó∞ùòÜùó∞ùóπùó≤ ùó∂ùóª ùó∂ùó¢ùó¶?

Not Running: The app is not launched yet.

Inactive: The app is in the foreground but not receiving input.

Active: The app is running and receiving events.

Background: The app is executing in the background.

Suspended: The app is in memory but not executing code.


8.) ùó™ùóµùóÆùòÅ ùó∂DataSource and Delegate

DataSource and Delegate are protocols used to separate data handling and user interaction logic in UIKit components like UITableView or UICollectionView.

DataSource provides the data (e.g., number of rows, cell content).

Delegate handles user interactions (e.g., row selection, editing).

UITableViewDataSource methods:               UITableViewDelegate methods:

numberOfRowsInSection                             didSelectRowAt

cellForRowAt                                      heightForRowAt


9.) What is a protocol in Swift?

A protocol in Swift defines a blueprint of methods, properties, or other requirements that a class, struct, or enum must adopt.
It allows for flexible and reusable code through abstraction.
Protocols support protocol-oriented programming, a key concept in Swift.

protocol Vehicle {
    func startEngine()
}

struct Car: Vehicle {
    func startEngine() {
        print("Car engine started")
    }
}


10.) What is an extension?

An extension allows you to add functionality to existing classes, structures, or enumerations without modifying their original implementation.

An extension in Swift is used to add new functionality to an existing class, struct, enum, or protocol without modifying its original source code.
It allows you to add methods, computed properties, and conform to protocols, helping keep your code organized and modular.

extension String {
    func isNumeric() -> Bool {
        return Double(self) != nil
    }
}

let value = "123"
print(value.isNumeric())


11.) Difference between Class and Struct 

The main difference is that classes are reference types, while structs are value types.

Class instances are shared via references; changes affect all references.

Struct instances are copied when assigned or passed, keeping data isolated.

Classes support inheritance, deinitializers, and reference counting, while structs do not.

‚úÖ When to Use Class and Struct:

Use **class** when:

You need inheritance, identity, or shared state.

You‚Äôre working with UIKit (e.g., UIView, UIViewController).

Use **struct** when:

You want safe, isolated, immutable copies.

You‚Äôre building data models in SwiftUI or functional architecture.


12.) when to use Class and when to use Struct ?

üî∏ 1. Class ‚Äî Reference Type

Stored in Heap memory: Objects live in memory until there are no references left.

Pass-by-Reference: When assigned to a new variable, only the reference (pointer) is copied, not the data.

Supports Inheritance: Classes can inherit properties and methods from another class.

Mutable Even If Declared with let: Unlike structs, properties of a class can be modified even if the instance is assigned to a constant

When you assign it to a new variable or pass it to a function, it shares the same reference (points to the same instance).

Supports:

‚úÖ Inheritance

‚úÖ Deinitializers

‚úÖ Use cases:

When you need to share state across multiple places (e.g., view controllers, managers).
When you need inheritance (e.g., UIViewController).
When the model is complex and mutable.


üî∏ 2. Struct ‚Äî Value Type

Stored in Stack memory: Structs are destroyed when they go out of scope, making them more memory efficient.

Pass-by-Value: Assigning a struct to a new variable copies the data

No Inheritance: Structs do not support inheritance

When you assign it to another variable or pass it to a function, it creates a copy.

Does not support:

‚ùå Inheritance

‚ùå Deinitializers

Structs are safer for data models when immutability or copying behavior is desired.

‚úÖ Use cases:

For lightweight data models (like coordinates, points, custom data types).
For safety and predictability (no unexpected changes from shared references).
Best for data-driven models in SwiftUI or value-type-based architectures.



13.) How do you pass data from one view to another in iOS?

There are multiple ways to pass data between views or view controllers in iOS depending on the use case. Common methods include Property Passing, Closures, Delegates, NotificationCenter, and Combine.
1. Property Passing (most common)
2. Closure (Callback)
3. Delegate Pattern
4. NotificationCenter
5. Combine (modern reactive way)



14.) What are SOLID principles ?

SOLID is an acronym for five design principles that help developers write cleaner, maintainable, and scalable code‚Äîespecially in object-oriented programming like Swift.
S ‚Äì Single Responsibility Principle (SRP)
O ‚Äì Open/Closed Principle
L ‚Äì Liskov Substitution Principle
I ‚Äì Interface Segregation Principle
D ‚Äì Dependency Inversion Principle

| Principle | Meaning                        |
| --------- | ------------------------------ |
| **S**     | One class = One responsibility |
| **O**     | Extend without modifying       |
| **L**     | Subclasses behave like parents |
| **I**     | Small, focused protocols       |
| **D**     | Code against abstractions      |


üß± 1. S ‚Äì Single Responsibility Principle (SRP)
Each class should have only one responsibility or reason to change.

‚úÖ Example: A class that fetches user data should not also be responsible for saving it to disk.
class UserFetcher {
    func fetchUser() { /* fetch logic */ }
}

class UserSaver {
    func saveUser() { /* save logic */ }
}

üß± 2. O ‚Äì Open/Closed Principle
Software entities should be open for extension but closed for modification.

‚úÖ Example: Use protocols and extensions to add behavior without modifying existing code.
protocol PaymentMethod {
    func pay(amount: Double)
}

class CreditCard: PaymentMethod {
    func pay(amount: Double) { /* logic */ }
}

class PayPal: PaymentMethod {
    func pay(amount: Double) { /* logic */ }
}

üß± 3. L ‚Äì Liskov Substitution Principle
Subtypes must be substitutable for their base types.

‚úÖ Example: You should be able to use a subclass in place of a superclass without breaking the program.
class Bird {
    func fly() {}
}

class Sparrow: Bird {
    override func fly() {}
}
‚ö†Ô∏è Don‚Äôt create a subclass that breaks expectations, like:
class Ostrich: Bird {
    override func fly() { /* This is incorrect ‚Äì ostrich can't fly */ }
}

üß± 4. I ‚Äì Interface Segregation Principle
Clients shouldn‚Äôt be forced to depend on interfaces they don‚Äôt use.

‚úÖ Example: Use smaller, specific protocols rather than a large one.
protocol Flyable {
    func fly()
}

protocol Swimmable {
    func swim()
}
protocol Bird {
    func fly()
    func swim()
}

üß± 5. D ‚Äì Dependency Inversion Principle
Depend on abstractions, not concrete implementations.

‚úÖ Example: Inject dependencies using protocols.
protocol APIService {
    func fetchData()
}

class NetworkManager: APIService {
    func fetchData() { /* fetch logic */ }
}

class ViewModel {
    var service: APIService
    init(service: APIService) {
        self.service = service
    }
}


